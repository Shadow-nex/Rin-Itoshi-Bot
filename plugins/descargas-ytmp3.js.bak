/*// - codigo hecho x dv.shadow ğŸŒ±
// - Rin Itoshi âš½

import fetch from 'node-fetch'
import yts from 'yt-search'
import axios from "axios"

let handler = async (m, { conn, text, command, usedPrefix }) => {
  try {
    if (!text) {
      return conn.reply(
        m.chat,
        `ğŸ§ª Ingresa el nombre de la canciÃ³n o un enlace de YouTube.\n\nğŸ‚ Ejemplo: ${usedPrefix + command} DJ Malam Pagi`,
        m
      )
    }

    let search = await yts(text)
    let video = search.videos[0]
    if (!video) {
      return conn.reply(m.chat, 'No se encontrÃ³ ningÃºn resultado en YouTube.', m)
    }

    const apiUrl = `https://api.vreden.my.id/api/v1/download/play/audio?query=${encodeURIComponent(video.url)}`
    const res = await fetch(apiUrl)
    const json = await res.json()

    if (!json?.result?.metadata || !json?.result?.download?.url) {
      return conn.reply(m.chat, 'âŒ No se pudo obtener el audio, intenta con otro nombre o link.', m)
    }

    const meta = json.result.metadata
    const dl = json.result.download

    const size = await getSize(dl.url)
    const sizeStr = size ? await formatSize(size) : 'Desconocido'

    await conn.sendMessage(m.chat, { react: { text: 'ğŸ•“', key: m.key } })

    const textoInfo = `\`\`\`âœ¿  ğ—¬ğ—”ğ—¦ğ—¦ğ—¨ - ğ—¬ğ—§ ğ— ğ—£ğŸ¯ âš½\n
ğŸ‚ TÃ­tulo : ${meta.title}
â±ï¸ DuraciÃ³n : ${meta.duration?.timestamp || video.timestamp || 'Desconocida'}
ğŸŒ± Canal : ${meta.author?.name || video.author?.name || 'Desconocido'}
ğŸš€ Vistas : ${meta.views?.toLocaleString('es-PE') || video.views?.toLocaleString('es-PE') || '0'}
ğŸŒ· TamaÃ±o : ${sizeStr}
ğŸ§ª Publicado : ${meta.ago || video.ago || 'Desconocido'}
ğŸ’¨ Link : ${meta.url || video.url}
\`\`\`\n*â‰¡ Enviando, espera un momento . . .*`

    // Enviar preview
    await conn.sendMessage(
      m.chat,
      {
        image: { url: meta.thumbnail || video.thumbnail },
        caption: textoInfo,
        contextInfo: {
          mentionedJid: [m.sender],
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
            newsletterJid: '120363401008003732@newsletter',
            serverMessageId: 100,
            newsletterName: 'ğŸ—¿ Toca aquÃ­ ğŸŒ±'
          },
          externalAdReply: {
            title: meta.title || video.title,
            body: "ğŸ‚ Descargando desde YouTube ğŸ§ª",
            thumbnailUrl: meta.thumbnail || video.thumbnail,
            sourceUrl: meta.url || video.url,
            mediaType: 1,
            renderLargerThumbnail: false
          }
        }
      },
      { quoted: m }
    )

    const audioBuffer = await (await fetch(dl.url)).buffer()

    await conn.sendMessage(m.chat, {
      audio: audioBuffer,
      fileName: `${meta.title}.mp3`,
      mimetype: "audio/mpeg",
      ptt: false,
      contextInfo: {
        externalAdReply: {
          title: meta.title,
          body: `ğŸ DuraciÃ³n: ${meta.duration?.timestamp || video.timestamp}`,
          mediaUrl: meta.url || video.url,
          sourceUrl: meta.url || video.url,
          thumbnailUrl: meta.thumbnail || video.thumbnail,
          mediaType: 1,
          renderLargerThumbnail: false
        }
      }
    }, { quoted: m })

    await conn.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } })
  } catch (e) {
    console.error('[Error en ytmp3]', e)
    await conn.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } })
    await conn.reply(m.chat, `âŒ *Error:* ${e.message}`, m)
  }
}

handler.command = ['ytmp3', 'song']
handler.tags = ['descargas']
handler.help = ['ytmp3 <texto o link>', 'song <texto>']

export default handler

async function getSize(url) {
  try {
    const response = await axios.head(url)
    const length = response.headers['content-length']
    return length ? parseInt(length, 10) : null
  } catch (error) {
    console.error("Error al obtener el tamaÃ±o:", error.message)
    return null
  }
}

async function formatSize(bytes) {
  const units = ['B', 'KB', 'MB', 'GB']
  let i = 0

  if (!bytes || isNaN(bytes)) return 'Desconocido'

  while (bytes >= 1024 && i < units.length - 1) {
    bytes /= 1024
    i++
  }

  return `${bytes.toFixed(2)} ${units[i]}`
}*/

// - cÃ³digo hecho x dv.shadow ğŸŒ±
// - Rin Itoshi âš½

import fetch from "node-fetch";

const handler = async (m, { conn, text, usedPrefix, command }) => {
  try {
    if (!text) {
      return conn.reply(m.chat, `âš ï¸ Ingresa el nombre de la canciÃ³n.\n\nğŸ“Œ Ejemplo:\n${usedPrefix + command} Happy Nation`, m);
    }

    const url = `https://api.vreden.my.id/api/v1/download/play/audio?query=${encodeURIComponent(text)}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`âŒ Error HTTP ${res.status}`);

    const json = await res.json();

    // --- DefiniciÃ³n de todas las keys ---
    const status = json?.status ?? false;
    const status_code = json?.status_code ?? 500;
    const creator = json?.creator ?? "Desconocido";

    const result = json?.result ?? {};
    const result_status = result?.status ?? false;
    const result_creator = result?.creator ?? "Desconocido";

    const metadata = result?.metadata ?? {};
    const {
      type,
      videoId,
      url: videoUrl,
      title,
      description,
      image,
      thumbnail,
      seconds,
      timestamp,
      duration,
      ago,
      views,
      author
    } = metadata;

    const author_name = author?.name ?? "Desconocido";
    const author_url = author?.url ?? "";

    const download = result?.download ?? {};
    const {
      status: download_status,
      quality,
      availableQuality,
      url: audioUrl,
      filename
    } = download;

    // --- Mensaje bonito con la info ---
    let info = `
â•­â”â”â”ã€” ğŸ¶ ğŒğ®ğ¬ğ¢ğœ ğƒğ¨ğ°ğ§ğ¥ğ¨ğšğ ğŸ¶ ã€•â”â”â¬£
â”ƒ ğŸ¼ *TÃ­tulo:* ${title}
â”ƒ ğŸ‘¤ *Autor:* ${author_name}
â”ƒ ğŸ“€ *Tipo:* ${type}
â”ƒ â±ï¸ *DuraciÃ³n:* ${timestamp} (${seconds}s)
â”ƒ ğŸ“… *Publicado:* ${ago}
â”ƒ ğŸ‘€ *Vistas:* ${views.toLocaleString()}
â”ƒ ğŸ§ *Calidad:* ${quality}
â”ƒ ğŸ”— *YouTube:* ${videoUrl}
â”ƒ ğŸ’¾ *Archivo:* ${filename}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â¬£
`;

    // --- Enviar mensaje con portada y botÃ³n de descarga ---
    await conn.sendMessage(m.chat, {
      image: { url: thumbnail },
      caption: info,
      contextInfo: {
        externalAdReply: {
          title: title,
          body: "Descarga disponible",
          thumbnailUrl: image,
          sourceUrl: videoUrl,
          mediaType: 1,
          renderLargerThumbnail: true
        }
      }
    }, { quoted: m });

    // --- Enviar el audio ---
    await conn.sendMessage(m.chat, {
      audio: { url: audioUrl },
      fileName: filename,
      mimetype: "audio/mpeg"
    }, { quoted: m });

  } catch (err) {
    console.error(err);
    conn.reply(m.chat, "âŒ OcurriÃ³ un error al procesar la canciÃ³n.", m);
  }
};

handler.help = ["play"].map(v => v + " <texto>");
handler.tags = ["downloader"];
handler.command = ["play"];

export default handler;